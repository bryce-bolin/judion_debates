{% extends "base.html" %}
{% block content %}
<style>
  .chat-wrap { max-width: 760px; margin: 0 auto; display: flex; flex-direction: column; height: 100%; }
  #messages { flex: 1; overflow-y: auto; padding-bottom: 96px; }

  /* Alignment: me on right, judge/others on left */
  .row-user   { display:flex; justify-content:flex-end; }
  .row-assist { display:flex; justify-content:flex-start; }

  /* Neutral dark bubbles */
  .bubble { padding:.75rem 1rem; border-radius: 12px; border:1px solid #333; max-width: 90%; }
  .bubble-user   { background:#1b1b1b; border-color:#2d2d2d; }
  .bubble-assist { background:#121212; border-color:#2a2a2a; }

  .meta { color:#aaa; font-size:.8rem; margin-bottom:.25rem; }
  .composer { position: sticky; bottom: 0; background:#000; padding:.5rem 0; z-index:10; border-top:1px solid #222; }
</style>

<div class="chat-wrap">
  <div class="mb-3">
    <h3 class="mb-1">{{ room.title }}</h3>
    {% if room.description %}<p class="muted mb-2">{{ room.description }}</p>{% endif %}
    <p class="small text-secondary">Room code: <strong>{{ room.code }}</strong></p>
  </div>

  <div id="messages">
    {% for m in messages %}
      {% set is_user = (m.role == 'user' and m.user == current_user.username) %}
      <div class="{{ 'row-user' if is_user else 'row-assist' }} mb-2">
        <div class="bubble {{ 'bubble-user' if is_user else 'bubble-assist' }}">
          <div class="meta"><strong>{{ m.user if m.user else 'AI' }}</strong></div>
          <div>{{ m.text | markdown | safe }}</div>
        </div>
      </div>
    {% else %}
      <div class="muted">No messages yet.</div>
    {% endfor %}
  </div>

  <form class="composer" action="{{ url_for('debate_message', code=room.code) }}" method="post">
    <label class="form-label">Message</label>
    <textarea name="text" rows="3" class="form-control mb-2" placeholder="Write an argument or counterargument…"></textarea>
    <button class="btn btn-primary">Send</button>
  </form>
</div>

<script>
  // Scroll to bottom on load
  (function() {
    const messages = document.getElementById("messages");
    messages.scrollTop = messages.scrollHeight;
  })();
</script>

<script src="https://cdn.socket.io/4.7.4/socket.io.min.js"></script>
<script>
(() => {
  const socket       = io();
  const roomKey      = "debate:{{ room.code }}";
  const messagesDiv  = document.getElementById("messages");
  const composerForm = document.querySelector(".composer");
  const textarea     = composerForm.querySelector("textarea");

  socket.emit("join", { room: roomKey });

  // --- helpers ---
  function safeHTML(s) {
    return (s || "")
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;")
      .replace(/\n/g, "<br>");
  }

  function appendBubble(msg, isMine, opts = {}) {
    const row = document.createElement("div");
    row.className = (isMine ? "row-user" : "row-assist") + " mb-2";
    const pendingAttr = opts.pending ? ' data-pending="1"' : '';
    row.innerHTML = `
      <div class="bubble ${isMine ? "bubble-user" : "bubble-assist"}"${pendingAttr}>
        <div class="meta"><strong>${msg.user || "Judge"}</strong></div>
        <div class="content">${safeHTML(msg.text)}</div>
      </div>
    `;
    messagesDiv.appendChild(row);
    messagesDiv.scrollTop = messagesDiv.scrollHeight;
    return row;
  }

  function removeTyping() {
    document.querySelectorAll('[data-typing="1"]').forEach(el => {
      const row = el.closest(".mb-2") || el;
      row.remove();
    });
  }

  function showTyping() {
    removeTyping();
    const wrap = document.createElement("div");
    wrap.className = "row-assist mb-2";
    wrap.innerHTML = `
      <div class="bubble bubble-assist" data-typing="1">
        <div class="meta"><strong>Judge</strong></div>
        <div><em>Judge is typing…</em></div>
      </div>`;
    messagesDiv.appendChild(wrap);
    messagesDiv.scrollTop = messagesDiv.scrollHeight;
  }

  // Try to resolve my pending (optimistic) bubble so we don't duplicate on echo
  function resolvePendingFor(text) {
    const pending = messagesDiv.querySelectorAll('.bubble[data-pending="1"] .content');
    for (const el of pending) {
      if (el.innerHTML === safeHTML(text)) {
        el.closest('.bubble').removeAttribute('data-pending');
        return true;
      }
    }
    return false;
  }

  // --- live messages from server ---
  socket.on("new_message", (msg) => {
    // If it's me and matches my pending bubble, don't duplicate
    if (msg.user === "{{ current_user.username }}") {
      if (resolvePendingFor(msg.text)) return;
    }
    // If it's the Judge (or anyone else), ensure typing indicator is gone
    removeTyping();
    appendBubble(msg, msg.user === "{{ current_user.username }}");
  });

  // --- submit via fetch: optimistic + typing, no reload ---
  composerForm.addEventListener("submit", async (e) => {
    e.preventDefault();

    const text = (textarea.value || "").trim();
    if (!text) return;

    // 1) Show my message immediately as 'pending'
    appendBubble({ user: "{{ current_user.username }}", text }, true, { pending: true });

    // 2) Show one typing bubble
    showTyping();

    // 3) POST without reload
    try {
      await fetch("{{ url_for('debate_message', code=room.code) }}", {
        method: "POST",
        headers: {
          "Content-Type": "application/x-www-form-urlencoded",
          "X-Requested-With": "XMLHttpRequest"
        },
        body: new URLSearchParams({ text })
      });
      textarea.value = "";
      textarea.focus();
      // Server will emit:
      //  - my message echo → resolvePendingFor
      //  - Judge message   → removeTyping + appendBubble
    } catch (err) {
      removeTyping();
      appendBubble({ user: "System", text: "(Send failed. Please try again.)" }, false);
      console.error(err);
    }
  });

  // Leave room when navigating away
  window.addEventListener("beforeunload", () => {
    socket.emit("leave", { room: roomKey });
  });

  // initial bottom
  messagesDiv.scrollTop = messagesDiv.scrollHeight;
})();
</script>
{% endblock %}