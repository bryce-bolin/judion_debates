{% extends "base.html" %}
{% block content %}
<style>
  .chat-wrap {
    max-width: 760px;
    margin: 0 auto;
    display: flex;
    flex-direction: column;
    height: 100%;
  }
  #messages { flex: 1; overflow-y: auto; padding-bottom: 96px; }

  /* Keep rows tidy and NEVER stretch bubbles vertically */
  .row-user,
  .row-assist {
    display: flex;
    justify-content: flex-start;
    align-items: flex-start !important;
    gap: .25rem;
  }
  .row-user   { justify-content: flex-end; }
  .row-assist { justify-content: flex-start; }

  /* Real chat bubbles that size to content (tighter) */
  .bubble {
    display: inline-flex;
    flex-direction: column;
    flex: 0 0 auto;
    width: auto;
    max-width: 70%;
    padding: 1.12rem 1.0rem .22rem;
    margin: .26rem 0;
    border-radius: 24px;
    border: 1px solid #333;
    background: #121212;
    line-height: 1.28;
    word-break: break-word;
    white-space: pre-wrap;
    height: auto !important;
    min-height: 0 !important;
  }

  .bubble-user   { background:#1b1b1b; border-color:#2d2d2d; }
  .bubble-assist { background:#121212; border-color:#2a2a2a; }

  /* Trim markdown spacing */
  .bubble > * { margin: 0; }
  .bubble p + p { margin-top: .3rem; }
  .bubble h1, .bubble h2, .bubble h3,
  .bubble h4, .bubble h5, .bubble h6 { margin: .2rem 0; line-height: 1.18; }
  .bubble ul, .bubble ol { margin: .25rem 0 .25rem 1.1rem; padding-left: 1.1rem; }
  .bubble blockquote { margin: .25rem 0; }
  .bubble pre, .bubble code { margin: 0; }
  .bubble * { max-width: 100%; }

  .composer {
    position: sticky; bottom: 0;
    background:#000; padding:.75rem 0;
    z-index:10; border-top:1px solid #222;
  }
  .sr-only{
    position:absolute;
    width:1px;
    height:1px;
    padding:0;
    margin:-1px;
    overflow:hidden;
    clip:rect(0,0,0,0);
    border:0;
  }
  .composer{
    display:flex;
    flex-direction:column;
    gap:.35rem;
  }
  .composer-shell{
    display:flex;
    align-items:center;
    gap:.45rem;
    background:#0d0d0d;
    border:1px solid #1f1f1f;
    border-radius:30px;
    padding:.1rem .35rem .1rem .35rem;
    overflow:hidden;
    order:2;
  }
  .composer-plus{
    border:none;
    background:transparent;
    padding:0 .45rem 0 .2rem;
    color:#fff;
    font-size:2rem;
    line-height:1;
    display:inline-flex;
    align-items:flex-start;
    justify-content:center;
    cursor:pointer;
    flex:0 0 auto;
    width:auto;
    height:auto;
    transform:translate(2px, -3px);
    -webkit-appearance:none;
    appearance:none;
  }
  .composer-plus:active{ transform:scale(.95); }
  .composer textarea{
    flex:1;
    border:none !important;
    background:transparent !important;
    resize:none;
    min-height:44px;
    max-height:8.5rem;
    overflow-y:auto;
    padding:.7rem .4rem .05rem;
    color:#fff !important;
    line-height:1.35;
    text-align:left;
    font-size:.95rem;
  }
  .composer textarea:focus{ outline:none; box-shadow:none; }
  .composer textarea::placeholder{ color:#8f8f8f; }
  .composer .send-btn{
    width:40px;
    height:40px;
    border-radius:999px !important;
    border:none;
    background:#fff;
    color:#000;
    font-weight:600;
    display:flex;
    align-items:center;
    justify-content:center;
    cursor:pointer;
    transition:transform .08s ease, opacity .12s ease;
  }
  .composer .send-btn:disabled{ opacity:.4; cursor:not-allowed; }
  .composer .send-btn:active{ transform:scale(.96); }
  .composer-attachments{
    display:flex;
    gap:.4rem;
    flex-wrap:wrap;
    margin-bottom:.35rem;
    order:1;
  }
  .composer-attachments[hidden]{ display:none; }
  .attachment-chip{
    position:relative;
    width:48px;
    height:48px;
    border:1px solid #2a2a2a;
    border-radius:12px;
    overflow:hidden;
  }
  .attachment-chip img{
    width:100%;
    height:100%;
    object-fit:cover;
    display:block;
  }
  .attachment-chip button{
    position:absolute;
    top:2px;
    right:2px;
    width:18px;
    height:18px;
    border:none;
    border-radius:50%;
    background:rgba(0,0,0,.7);
    color:#fff;
    font-size:.75rem;
    line-height:1;
    cursor:pointer;
  }
</style>

<div class="chat-wrap">
  <div class="mb-3">
    <h3 class="mb-1">{{ room.title }}</h3>
    {% if room.description %}<p class="muted mb-2">{{ room.description }}</p>{% endif %}
  </div>

  <div id="messages">
    {% for m in messages %}
      {% set is_user = (m.role == 'user' and m.user == current_user.username) %}
      {% set sender = m.user or 'AI' %}
      {% set is_ai = sender|lower == 'ai' %}
      {% if is_ai %}
        <div class="row-assist mb-2">
          <div class="ai-line md">{{ m.text | markdown | safe }}</div>
        </div>
      {% else %}
        <div class="{{ 'row-user' if is_user else 'row-assist' }} mb-2">
          <div class="bubble {{ 'bubble-user' if is_user else 'bubble-assist' }} md">
            <div class="md-body">{{ m.text | markdown | safe }}</div>
          </div>
        </div>
      {% endif %}
    {% else %}
      <div class="muted empty-state">No messages yet. Start typing below.</div>
    {% endfor %}
  </div>

  <form class="composer" action="{{ url_for('solo_message', sid=room.sid) }}" method="post">
    <label class="sr-only" for="solo-message">Message</label>
    <div class="composer-attachments" hidden aria-live="polite"></div>
    <div class="composer-shell">
      <button type="button" class="composer-plus" aria-label="Add image">+</button>
      <input type="file" class="composer-file" accept="image/*" multiple hidden>
      <textarea id="solo-message" name="text" rows="1" class="form-control" placeholder="Send a message…" autofocus aria-label="Message"></textarea>
      <button class="btn btn-primary send-btn" type="submit" aria-label="Send message">↑</button>
    </div>
  </form>
</div>

<script>
  // Auto-scroll to bottom on load
  (function () {
    const messages = document.getElementById("messages");
    messages.scrollTop = messages.scrollHeight;
  })();
</script>

<!-- DO NOT include main.js here (base.html already does) -->

<script src="https://cdn.socket.io/4.7.4/socket.io.min.js"></script>
<script>
(() => {
  const socket = io();
  const roomKey = "solo:{{ room.sid }}";
  socket.emit("join", { room: roomKey });

  const messagesDiv = document.getElementById("messages");
  const composerForm = document.querySelector(".composer");
  const textarea = composerForm.querySelector("textarea");
  const plusButton = composerForm.querySelector(".composer-plus");
  const fileInput = composerForm.querySelector(".composer-file");
  const attachmentsWrap = composerForm.querySelector(".composer-attachments");
  let pendingAttachments = [];

  function autoSizeTextarea(el) {
    if (!el) return;
    const computed = getComputedStyle(el);
    const maxPx = parseFloat(computed.maxHeight) || 136;
    el.style.height = "auto";
    const next = Math.min(el.scrollHeight, maxPx);
    el.style.height = `${next}px`;
    el.style.overflowY = el.scrollHeight > maxPx ? "auto" : "hidden";
  }
  autoSizeTextarea(textarea);
  textarea.addEventListener("input", () => autoSizeTextarea(textarea));
  textarea.addEventListener("keydown", (event) => {
    if (event.key === "Enter" && !event.shiftKey) {
      event.preventDefault();
      composerForm.requestSubmit();
    }
  });
  plusButton.addEventListener("click", () => fileInput.click());
  fileInput.addEventListener("change", () => {
    const files = Array.from(fileInput.files || []);
    files.forEach((file) => {
      if (!file.type.startsWith("image/")) return;
      const reader = new FileReader();
      reader.onload = () => {
        pendingAttachments.push({
          name: file.name || "image",
          data: reader.result,
        });
        renderAttachments();
      };
      reader.readAsDataURL(file);
    });
    fileInput.value = "";
  });

  // Escape fallback (only used if no client markdown helper exists)
  function escapeHTML(str) {
    return (str || "")
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;")
      .replace(/\n/g, "<br>");
  }

  // Prefer client-side markdown renderer (if provided globally)
  function renderClientMarkdown(text) {
    if (window.renderMarkdown) return window.renderMarkdown(text || "");
    return escapeHTML(text || "");
  }

  // Ask the global code enhancer (from base.html) to wrap code blocks
  function enhanceCode(el) {
    if (window.enhanceCodeBlocks) window.enhanceCodeBlocks(el);
  }

  // Append a message node (bubble for humans, plain line for AI)
  function appendMessage(msg, isMineOverride) {
    const sender = msg.user || "";
    const isMine = typeof isMineOverride === "boolean"
      ? isMineOverride
      : sender === "{{ current_user.username }}";
    const isAI = sender.toLowerCase() === "ai";

    const row = document.createElement("div");
    row.className = (isMine ? "row-user" : "row-assist") + " mb-2";

    if (isAI) {
      row.innerHTML = `<div class="ai-line md"></div>`;
      row.querySelector(".ai-line").innerHTML = renderClientMarkdown(msg.text);
    } else {
      row.innerHTML = `
        <div class="bubble ${isMine ? "bubble-user" : "bubble-assist"} md">
          <div class="md-body"></div>
        </div>
      `;
      row.querySelector(".md-body").innerHTML = renderClientMarkdown(msg.text);
    }

    messagesDiv.appendChild(row);

    // Single header-style copy button via the global wrapper
    enhanceCode(row);

    messagesDiv.scrollTop = messagesDiv.scrollHeight;
  }

  function renderAttachments() {
    attachmentsWrap.innerHTML = "";
    pendingAttachments.forEach((att, idx) => {
      const chip = document.createElement("div");
      chip.className = "attachment-chip";
      chip.innerHTML = `
        <img src="${att.data}" alt="Attachment ${idx + 1}">
        <button type="button" aria-label="Remove attachment">&times;</button>
      `;
      chip.querySelector("button").addEventListener("click", () => {
        pendingAttachments.splice(idx, 1);
        renderAttachments();
      });
      attachmentsWrap.appendChild(chip);
    });
    attachmentsWrap.hidden = pendingAttachments.length === 0;
  }

  function buildPayload(text) {
    const mdImages = pendingAttachments.map((att) => `![${att.name}](${att.data})`);
    if (text && mdImages.length) {
      return `${text}\n\n${mdImages.join("\n\n")}`;
    }
    if (!text && mdImages.length) {
      return mdImages.join("\n\n");
    }
    return text;
  }

  function clearAttachments() {
    pendingAttachments = [];
    attachmentsWrap.innerHTML = "";
    attachmentsWrap.hidden = true;
  }

  // remove "AI is typing..." bubbles
  function removeTyping() {
    document.querySelectorAll('[data-typing="1"]').forEach(el => {
      const row = el.closest(".mb-2") || el;
      row.remove();
    });
  }

  function showTypingAtEnd() {
    removeTyping();
    const wrap = document.createElement("div");
    wrap.className = "row-assist mb-2";
    wrap.innerHTML = `
      <div class="ai-line" data-typing="1"><em>AI is typing...</em></div>`;
    messagesDiv.appendChild(wrap);
    messagesDiv.scrollTop = messagesDiv.scrollHeight;
  }

  let waitingForOwnEcho = false;

  socket.on("new_message", (msg) => {
    const isMine = msg.user === "{{ current_user.username }}";
    const isAI   = (msg.user || "").toLowerCase() === "ai";
    document.querySelector(".empty-state")?.remove();

    if (isAI) {
      removeTyping();
      appendMessage(msg, false);
      return;
    }

    // human message (including ours)
    appendMessage(msg, isMine);

    if (isMine || waitingForOwnEcho) {
      showTypingAtEnd();
      waitingForOwnEcho = false;
    }
  });

  composerForm.addEventListener("submit", async (e) => {
    e.preventDefault();

    const rawText = textarea.value || "";
    const trimmed = rawText.trim();
    const payload = buildPayload(trimmed);
    if (!payload) return;

    // clear immediately; wait for echoed message to avoid duplicates
    textarea.value = "";
    autoSizeTextarea(textarea);
    waitingForOwnEcho = true;

    try {
      await fetch("{{ url_for('solo_message', sid=room.sid) }}", {
        method: "POST",
        headers: {
          "Content-Type": "application/x-www-form-urlencoded",
          "X-Requested-With": "XMLHttpRequest"
        },
        body: new URLSearchParams({ text: payload })
      });
      clearAttachments();
    } catch (err) {
      waitingForOwnEcho = false;
      removeTyping();
      appendMessage({ user: "System", text: "(Send failed. Please try again.)" }, false);
      console.error(err);
    }
  });

  window.addEventListener("beforeunload", () => {
    socket.emit("leave", { room: roomKey });
  });

  messagesDiv.scrollTop = messagesDiv.scrollHeight;
})();
</script>
{% endblock %}
