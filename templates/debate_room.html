{% extends "base.html" %}
{% block content %}
<style>
  .chat-wrap {
    max-width: 760px;
    margin: 0 auto;
    display: flex;
    flex-direction: column;
    height: 100%;
  }
  #messages { flex: 1; overflow-y: auto; padding-bottom: 96px; }

  /* Keep rows tidy and NEVER stretch bubbles vertically */
  .row-user,
  .row-assist {
    display: flex;
    justify-content: flex-start;
    align-items: flex-start !important;
    gap: .25rem;
  }
  .row-user   { justify-content: flex-end; }
  .row-assist { justify-content: flex-start; }

  /* Compact bubbles */
  .bubble {
    display: inline-flex;
    flex-direction: column;
    flex: 0 0 auto;
    width: auto;
    max-width: 70%;
    padding: 1.15rem 1.02rem .24rem;
    margin: .3rem 0;
    border-radius: 20px;
    border: 1px solid #333;
    line-height: 1.32;
    word-break: break-word;
    white-space: pre-wrap;
    height: auto !important;
    min-height: 0 !important;
  }

  .bubble-user   { background:#1b1b1b; border-color:#2d2d2d; }
  .bubble-assist { background:#121212; border-color:#2a2a2a; }

  /* Trim markdown spacing */
  .bubble > * { margin: 0; }
  .bubble p + p { margin-top: .35rem; }
  .bubble h1, .bubble h2, .bubble h3,
  .bubble h4, .bubble h5, .bubble h6 { margin: .25rem 0; line-height: 1.2; }
  .bubble ul, .bubble ol { margin: .3rem 0 .3rem 1.1rem; padding-left: 1.1rem; }
  .bubble blockquote { margin: .3rem 0; }
  .bubble pre, .bubble code { margin: 0; }
  .bubble * { max-width: 100%; }

  .meta { color:#aaa; font-size:.8rem; margin-bottom:.25rem; }
  .composer {
    position: sticky; bottom: 0;
    background:#000; padding:.75rem 0;
    z-index:10; border-top:1px solid #222;
  }
  .sr-only{
    position:absolute;
    width:1px;
    height:1px;
    padding:0;
    margin:-1px;
    overflow:hidden;
    clip:rect(0,0,0,0);
    border:0;
  }
  .composer{
    display:flex;
    flex-direction:column;
    gap:.35rem;
  }
  .composer-shell{
    display:flex;
    align-items:center;
    gap:.45rem;
    background:#0d0d0d;
    border:1px solid #1f1f1f;
    border-radius:30px;
    padding:.1rem .35rem .1rem .35rem;
    overflow:hidden;
    order:2;
  }
  .composer-plus{
    border:none;
    background:transparent;
    padding:0 .45rem 0 .2rem;
    color:#fff;
    font-size:2rem;
    line-height:1;
    display:inline-flex;
    align-items:flex-start;
    justify-content:center;
    cursor:pointer;
    flex:0 0 auto;
    width:auto;
    height:auto;
    transform:translate(2px, -3px);
    -webkit-appearance:none;
    appearance:none;
  }
  .composer-plus:active{ transform:scale(.95); }
  .composer textarea{
    flex:1;
    border:none !important;
    background:transparent !important;
    resize:none;
    min-height:44px;
    max-height:8.5rem;
    overflow-y:auto;
    padding:.7rem .4rem .05rem;
    color:#fff !important;
    line-height:1.35;
    text-align:left;
    font-size:.95rem;
  }
  .composer textarea:focus{ outline:none; box-shadow:none; }
  .composer textarea::placeholder{ color:#8f8f8f; }
  .composer .send-btn{
    width:40px;
    height:40px;
    border-radius:999px !important;
    border:none;
    background:#fff;
    color:#000;
    font-weight:600;
    display:flex;
    align-items:center;
    justify-content:center;
    cursor:pointer;
    transition:transform .08s ease, opacity .12s ease;
  }
  .composer .send-btn:disabled{ opacity:.4; cursor:not-allowed; }
  .composer .send-btn:active{ transform:scale(.96); }
    .composer-attachments{
      display:flex;
      gap:.4rem;
      flex-wrap:wrap;
      margin-bottom:.35rem;
      order:1;
    }
  .composer-attachments[hidden]{ display:none; }
  .attachment-chip{
    position:relative;
    width:48px;
    height:48px;
    border:1px solid #2a2a2a;
    border-radius:12px;
    overflow:hidden;
  }
  .attachment-chip img{
    width:100%;
    height:100%;
    object-fit:cover;
    display:block;
  }
  .attachment-chip button{
    position:absolute;
    top:2px;
    right:2px;
    width:18px;
    height:18px;
    border:none;
    border-radius:50%;
    background:rgba(0,0,0,.7);
    color:#fff;
    font-size:.75rem;
    line-height:1;
    cursor:pointer;
  }
</style>

<div class="chat-wrap">
  <div class="mb-3">
    <h3 class="mb-1">{{ room.title }}</h3>
    {% if room.description %}<p class="muted mb-2">{{ room.description }}</p>{% endif %}
    <p class="small text-secondary">Room code: <strong>{{ room.code }}</strong></p>
  </div>

  <div id="messages">
    {% for m in messages %}
      {% set is_user = (m.role == 'user' and m.user == current_user.username) %}
      {% set is_judge = (m.user or '')|lower == 'judge' %}
      {% if is_judge %}
        <div class="row-assist mb-2">
          <div class="ai-line md">{{ m.text | markdown | safe }}</div>
        </div>
      {% else %}
        <div class="{{ 'row-user' if is_user else 'row-assist' }} mb-2">
          <!-- add md class + md-body so JS can enhance code blocks -->
          <div class="bubble {{ 'bubble-user' if is_user else 'bubble-assist' }} md">
            <div class="meta"><strong>{{ m.user if m.user else 'AI' }}</strong></div>
            <div class="md-body">{{ m.text | markdown | safe }}</div>
          </div>
        </div>
      {% endif %}
    {% else %}
      <div class="muted empty-state">No messages yet.</div>
    {% endfor %}
  </div>

  <form class="composer" action="{{ url_for('debate_message', code=room.code) }}" method="post">
    <label class="sr-only" for="debate-message">Message</label>
    <div class="composer-attachments" hidden aria-live="polite"></div>
    <div class="composer-shell">
      <button type="button" class="composer-plus" aria-label="Add image">+</button>
      <input type="file" class="composer-file" accept="image/*" multiple hidden>
      <textarea id="debate-message" name="text" rows="1" class="form-control" placeholder="Write an argument or counterargument…" aria-label="Message"></textarea>
      <button class="btn btn-primary send-btn" type="submit" aria-label="Send message">↑</button>
    </div>
  </form>
</div>

<script>
  // Scroll to bottom on load
  (function() {
    const messages = document.getElementById("messages");
    messages.scrollTop = messages.scrollHeight;
  })();
</script>

<script src="https://cdn.socket.io/4.7.4/socket.io.min.js"></script>
<script>
(() => {
  const socket = io();
  const roomKey = "debate:{{ room.code }}";
  socket.emit("join", { room: roomKey });

  const messagesDiv  = document.getElementById("messages");
  const composerForm = document.querySelector(".composer");
  const textarea     = composerForm.querySelector("textarea");
  const plusButton   = composerForm.querySelector(".composer-plus");
  const fileInput    = composerForm.querySelector(".composer-file");
  const attachmentsWrap = composerForm.querySelector(".composer-attachments");
  let pendingAttachments = [];

  function autoSizeTextarea(el) {
    if (!el) return;
    const computed = getComputedStyle(el);
    const maxPx = parseFloat(computed.maxHeight) || 136;
    el.style.height = "auto";
    const next = Math.min(el.scrollHeight, maxPx);
    el.style.height = `${next}px`;
    el.style.overflowY = el.scrollHeight > maxPx ? "auto" : "hidden";
  }
  autoSizeTextarea(textarea);
  textarea.addEventListener("input", () => autoSizeTextarea(textarea));
  textarea.addEventListener("keydown", (event) => {
    if (event.key === "Enter" && !event.shiftKey) {
      event.preventDefault();
      composerForm.requestSubmit();
    }
  });
  plusButton.addEventListener("click", () => fileInput.click());
  fileInput.addEventListener("change", () => {
    const files = Array.from(fileInput.files || []);
    files.forEach((file) => {
      if (!file.type.startsWith("image/")) return;
      const reader = new FileReader();
      reader.onload = () => {
        pendingAttachments.push({
          name: file.name || "image",
          data: reader.result,
        });
        renderAttachments();
      };
      reader.readAsDataURL(file);
    });
    fileInput.value = "";
  });

  // Fallback escape
  function escapeHTML(str) {
    return (str || "")
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;")
      .replace(/\n/g, "<br>");
  }

  // Client markdown renderer hook
  function renderClientMarkdown(text) {
    if (window.renderMarkdown) return window.renderMarkdown(text || "");
    return escapeHTML(text || "");
  }

  // Add copy buttons to code blocks (from main.js)
  function enhance(el) {
    if (window.addCopyButtonsIn) window.addCopyButtonsIn(el);
  }

  // Append a message (bubble for humans, plain line for Judge)
  function appendMessage(msg, isMine) {
    const sender = msg.user || "Judge";
    const isJudge = sender.toLowerCase() === "judge";
    const row = document.createElement("div");
    row.className = (isMine ? "row-user" : "row-assist") + " mb-2";

    if (isJudge) {
      row.innerHTML = `<div class="ai-line md"></div>`;
      row.querySelector(".ai-line").innerHTML = renderClientMarkdown(msg.text);
      window.enhanceCodeBlocks(row);
    } else {
      row.innerHTML = `
        <div class="bubble ${isMine ? "bubble-user" : "bubble-assist"} md">
          <div class="meta"><strong>${escapeHTML(sender)}</strong></div>
          <div class="md-body"></div>
        </div>
      `;
      row.querySelector(".md-body").innerHTML = renderClientMarkdown(msg.text);
      enhance(row);
      window.enhanceCodeBlocks(row);
    }

    messagesDiv.appendChild(row);
    messagesDiv.scrollTop = messagesDiv.scrollHeight;
  }

  function renderAttachments() {
    attachmentsWrap.innerHTML = "";
    pendingAttachments.forEach((att, idx) => {
      const chip = document.createElement("div");
      chip.className = "attachment-chip";
      chip.innerHTML = `
        <img src="${att.data}" alt="Attachment ${idx + 1}">
        <button type="button" aria-label="Remove attachment">&times;</button>
      `;
      chip.querySelector("button").addEventListener("click", () => {
        pendingAttachments.splice(idx, 1);
        renderAttachments();
      });
      attachmentsWrap.appendChild(chip);
    });
    attachmentsWrap.hidden = pendingAttachments.length === 0;
  }

  function buildPayload(text) {
    const mdImages = pendingAttachments.map((att) => `![${att.name}](${att.data})`);
    if (text && mdImages.length) {
      return `${text}\n\n${mdImages.join("\n\n")}`;
    }
    if (!text && mdImages.length) {
      return mdImages.join("\n\n");
    }
    return text;
  }

  function clearAttachments() {
    pendingAttachments = [];
    attachmentsWrap.innerHTML = "";
    attachmentsWrap.hidden = true;
  }

  // Typing bubble
  let typingEl = null;
  function showTypingAtEnd() {
    hideTyping();
    typingEl = document.createElement("div");
    typingEl.className = "row-assist mb-2";
    typingEl.innerHTML = `
      <div class="ai-line" data-typing="1"><em>Judge is typing...</em></div>`;
    messagesDiv.appendChild(typingEl);
    messagesDiv.scrollTop = messagesDiv.scrollHeight;
  }
  function hideTyping() {
    if (typingEl && typingEl.parentNode) typingEl.parentNode.removeChild(typingEl);
    typingEl = null;
  }

  // Avoid duplicates: do NOT append optimistically.
  let waitingForOwnEcho = false;

  socket.on("new_message", (msg) => {
    const isMine = msg.user === "{{ current_user.username }}";
    const isJudge = (msg.user || "").toLowerCase() === "judge";
    document.querySelector(".empty-state")?.remove();

    if (isJudge) {
      hideTyping();
      appendMessage(msg, false);
      return;
    }

    // human message (including ours) arrives from server
    appendMessage(msg, isMine);

    // after our own echo, show "Judge is typing..."
    if (isMine || waitingForOwnEcho) {
      showTypingAtEnd();
      waitingForOwnEcho = false;
    }
  });

  composerForm.addEventListener("submit", async (e) => {
    e.preventDefault();
    const rawText = textarea.value || "";
    const trimmed = rawText.trim();
    const payload = buildPayload(trimmed);
    if (!payload) return;

    // Clear immediately; wait for server echo to append (prevents duplicates)
    textarea.value = "";
    autoSizeTextarea(textarea);
    waitingForOwnEcho = true;

    try {
      await fetch("{{ url_for('debate_message', code=room.code) }}", {
        method: "POST",
        headers: {
          "Content-Type": "application/x-www-form-urlencoded",
          "X-Requested-With": "XMLHttpRequest"
        },
        body: new URLSearchParams({ text: payload })
      });
      clearAttachments();
      // Echo + judge reply will arrive via socket events
    } catch (err) {
      waitingForOwnEcho = false;
      hideTyping();
      appendMessage({ user: "System", text: "(Send failed. Please try again.)" }, false);
      console.error(err);
    }
  });

  // leave room on unload
  window.addEventListener("beforeunload", () => {
    socket.emit("leave", { room: roomKey });
  });

  // Streaming removed: rely purely on sockets
})();
</script>
{% endblock %}
